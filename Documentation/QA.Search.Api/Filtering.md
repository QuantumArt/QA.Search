## Фильтрация по полям

Фильтрация документов по значениям полей задается в поле `$where`.
Можно задать условия на одно или несколько различных полей:

```json
{
  "$from": "qp.news",
  "$where": {
    "Regions": { "Alias": ["moskva", "spb"] },
    "Groups.Title": "Новости Абонентам"
  }
}
```

Поля вложенных объектов можно объявлять как через точку, так и во вложенной форме.

Условия на разные поля документа объединяются через AND. Условия внутри массива значений
одного поля объединяются через OR. Таким образом, в примере выше мы выбираем все новости,
которые имеют регион "moskva" или "spb" и принадлежат к группе "Новости Абонентам".

Если поле, для которого задано условие, в исходных документах представлено не скалярным
значением, а списком (или является полем одного из объектов в списке), то документ
попадет в выдачу, когда условие выполняется хотя бы для одного из элементов этого списка.

Например, данный документ будет удовлетворять условию выше:

```json
{
  "Title": "Какая-то новость",
  "Regions": [{ "Alias": "moskva" }, { "Alias": "tula" }],
  "Groups": [
    { "Title": "Новости Абонентам" },
    { "Title": "Новости корпоративным клиентам" }
  ]
}
```

Фильтровать можно по всем полям документа, включая служебные `_id` и `_index`.

### Расширенные условия

Если необходимо фильтровать по каким-то более сложным условиям, чем явные значения полей,
можно воспользоваться **расширенным синтаксисом** условий:

```json
{
  "$from": "qp.news",
  "$where": {
    "Regions": { "Alias": { "$all": ["moskva", "spb"] } },
    "Groups.Title": { "$ne": "Новости Абонентам" },
    "PublishDate": {
      "$gte": "2018-01-01T00:00:00",
      "$lt": "2019-01-01T00:00:00"
    }
  }
}
```

В примере выше: выбираем все новости, которые имеют регион "moskva" **и** "spb",
**не** принадлежат к группе "Новости Абонентам" и имеют дату публикации с 2018 по 2019 год.

Каждое расширенное условие на поле представляет собой объект со следующими полями:

- `$eq: scalar` — равно,
- `$ne: scalar` — не равно,
- `$in: scalar[]` — содержит одно из `@alias $any`,
- `$any: scalar[]` — содержит одно из `@alias $in`,
- `$all: scalar[]` — содержит все из,
- `$none: scalar[]` — не содержит ни одного из,
- `$lt: scalar` — меньше,
- `$lte: scalar` — меньше или равно,
- `$gt: scalar` — больше,
- `$gte: scalar` — больше или равно.

Предикаты внутри одного объекта объединяются через AND. Так же, как и с массивом явных
значений, мы можем объединить несколько расширенных условий на одно поле через OR:

```json
{
  "$from": "qp.*",
  "$where": {
    "Regions.Alias": [{ "$eq": null }, { "$in": ["moskva", "spb"] }]
  }
}
```

### Комбинирование условий

Если необходимо задать фильтр, когда условия на одно поле зависят от условий на другое,
мы можем воспользоваться булевскими комбинаторами:

- `$every: Condition[]` — должны быть выполнены все условия из списка,
- `$some: Condition[]` — должно быть выполнено хотя бы одно условие из списка,
- `$not: Condition` — условие не должно быть выполнено.

Например, ищем тарифы с ценой до 500 в Калуге или до 1000 в Москве:

```json
{
  "$from": "dpc.tariff",
  "$where": {
    "$some": [
      {
        "Regions.Alias": "kaluga",
        "ParametersByAlias.SubscriptionFee.NumValue": { "$lte": 500 }
      },
      {
        "Regions.Alias": "moskva",
        "ParametersByAlias.SubscriptionFee.NumValue": { "$lte": 1000 }
      }
    ]
  }
}
```

Все комбинаторы (`$every`, `$some`, `$not`) могут быть вложены друг в друга произвольным образом:

```json
{
  "$from": "dpc.tariff",
  "$where": {
    "$every": [
      {
        "$some": [{ "Regions.Alias": "kaluga" }, { "Regions.Alias": "moskva" }]
      },
      {
        "$not": {
          "ParametersByAlias.SubscriptionFee.NumValue": { "$gt": 1000 }
        }
      }
    ]
  }
}
```
